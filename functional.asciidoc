= Functional Programming

Het basisprincipe achter functioneel programmeren is statelessness of immutability, nl. het nooit _wijzigen_ van waardes.
Bv. indien men een lijst wil uitbreiden met een element, moet men een _nieuwe_ lijst aanmaken met dat extra element in.

.Python Voorbeeld
[%collapsible]
====
[source,python]
----
x = 5   # Ok
x = 6   # Mag niet, wijzigt x

ns = [1, 2, 3]  # Ok
ns.append(4)    # Mag niet, wijzigt lijst
ks = [*ns, 4]   # Ok
----
====

.JavaScript Voorbeeld
[%collapsible]
====
[source,javascript]
----
let x = 5;    // Ok
x = 6         // Mag niet, wijzigt x

const ns = [1, 2, 3];  // Ok
ns.push(4);            // Mag niet, wijzigt lijst
const ks = [...ns, 4]; // Ok
----
====

== Statelessness

Functies kunnen vaak op twee manieren geschreven worden:

* Ze wijzigen hun argument en geven niets terug (= stateful, imperatieve stijl).
* Ze laten hun argument met rust en geven een nieuwe waarde terug (= stateless, functionele stijl).

.Voorbeeld in Python
[%collapsible]
====
[source,python]
----
# Imperative style modifies parameter
def double_elements(ns):
  for i in range(len(ns)):
    ns[i] *= 2


# Functional style creates new list
def double_elements(ns):
  result = []
  for n in ns:
    result.append(n * 2)
  return result
----
====

.Voorbeeld in JavaScript
[%collapsible]
====
[source,javascript]
----
// Imperative style modifies parameter
function doubleAll(ns)
{
    for ( let i = 0; i !== ns.length; ++i )
    {
        ns[i] *= 2;
    }
}


// Functional style creates new list
function doubleAll(ns)
{
    const result = [];

    for ( const n of ns )
    {
        result.append(n);
    }

    return result;
}
----
====

== Comprehensions

Comprehensions laten toe gemakkelijk met lijsten/sets/dictionaries te werken.

=== Mapping

Mapping houdt in dat men op elk element van een lijst eenzelfde operatie toepast en de resultaten verzamelt in een nieuwe lijst.

.Python Voorbeelden
[%collapsible]
====
[source,python]
----
def double_all(ns):
    return [n * 2 for n in ns]

def names(people):
    return [person.name for person in people]

def average_grade(students):
    all_grades = [student.grade for group in year for student in group]
    return sum(all_grades) / len(all_grades)
----
====

.C# Voorbeelden
[%collapsible]
====
[source,csharp]
----
IEnumerable<int> DoubleAll(IEnumerable<int> ns)
{
    return from n in ns
           select n * 2;
}

IEnumerable<string> DoubleAll(IEnumerable<Person> people)
{
    return from person in people
           select person.Name;
}
----
====

=== Filtering

.Python Voorbeelden
[%collapsible]
====
[source,python]
def names_of_men(people):
    return [person.name for person in people
                        if person.male]
```
====

.C# Voorbeelden
[%collapsible]
====
[source,csharp]
----
IEnumerable<string> NamesOfMen(IEnumerable<string> people)
{
    return from person in people
           where person.IsMale
           select person.Name;
}
----
====

== First Class Functions and Higher Order Functions

*First class values* zijn waardes die

* in een variabele kunnen bewaard worden,
* als parameter kunnen doorgegeven worden, en
* teruggegeven kunnen worden als resultaat.

Typische voorbeelden zijn integers, strings, booleans, objecten, etc.
Functies zijn in de meeste talen echter ook first-class values.

Een *higher order function* is een functie die als parameter ontvangt.

[NOTE]
====
Merk op dat indien men in een OO taal een object doorgeeft als parameter, dit in een verzameling van functies is die worden doorgegeven.
====

.Python Voorbeelden
[%collapsible]
====
[source,python]
----
def is_odd(x):
  return x % 2 != 0

xs = [1,2,3,4,5]

filter(is_odd, xs)   # [1, 3, 5]
----
====

.JavaScript Voorbeelden
[%collapsible]
====
[source,javascript]
----
function isOdd(x)
{
    return x % 2 !== 0;
}

const xs = [1,2,3,4,5];
xs.filter(isOdd);   // [1,3,5]
----
====


== Lambda Expressions

```python
xs = [1,2,3,4,5]

odd_xs = filter(lambda x: x % 2 != 0, xs)
```

== Recursion

```python
def names(people):
  if people:
    first, *rest = people
    return [first.name, *names(rest)]
  else:
    return []
```

== Persistent Data Structures

* Linked lists
* Trees
* Performance impact (structural sharing)
